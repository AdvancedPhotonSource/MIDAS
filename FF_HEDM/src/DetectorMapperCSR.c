// =========================================================================
// DetectoMapperCSR.c
//
// Purpose: Converts map files generated by the original DetectorMapper
//          (Map.bin, nMap.bin) into Compressed Sparse Row (CSR) format
//          (MapCSR.*).
//
// Usage: ./DetectoMapperCSR <parameter_file.txt>
//
// Input Files (must exist in the same directory):
//   - Map.bin: Binary file containing array of 'struct data {int y, z; double frac;}'
//   - nMap.bin: Binary file containing array of 'int {count, offset}' pairs.
//   - <parameter_file.txt>: Text file containing at least NrPixelsY and NrPixelsZ.
//
// Output Files:
//   - MapCSR.hdr: Text file with CSR dimensions (rows, cols, nnz).
//   - MapCSR_values.bin: Binary file with non-zero contribution fractions (double).
//   - MapCSR_col_indices.bin: Binary file with linear pixel indices for non-zeros (int).
//   - MapCSR_row_ptr.bin: Binary file with row start pointers (int).
// =========================================================================
// gcc src/DetectorMapperCSR.c -o bin/DetectorMapperCSR -I/home/beams/S1IDUSER/opt/MIDAS/FF_HEDM/build/include -L/home/beams/S1IDUSER/opt/MIDAS/FF_HEDM/build/lib -O3 -ldl -lm

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <sys/stat.h>
#include <errno.h>
#include <stdarg.h>
#include <ctype.h>

// Define the structure expected in Map.bin
struct data {
	int y;
	int z;
	double frac;
};

// --- Error Checking ---
static void check (int test, const char * message, ...) {
    if (test) {
        va_list args;
        va_start (args, message);
        fprintf(stderr, "Fatal Error: ");
        vfprintf(stderr, message, args);
        va_end (args);
        fprintf(stderr, " (errno: %s)\n", test > 0 ? strerror(errno) : "N/A"); // Show errno message if applicable
        exit(EXIT_FAILURE);
    }
}

// --- File Size Helper ---
long get_file_size(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1; // Error or file not found
}

int main(int argc, char *argv[]) {

    printf("MapConverter: Converting Map.bin/nMap.bin to CSR format.\n");

    // --- Argument Check ---
    check(argc != 2, "Usage: %s <parameter_file.txt>", argv[0]);
    char *ParamFN = argv[1];

    // --- Read Parameters (NrPixelsY, NrPixelsZ only) ---
    int NrPixelsY = 0, NrPixelsZ = 0;
    FILE *paramFile = fopen(ParamFN, "r");
    check(paramFile == NULL, "Failed to open parameter file '%s'", ParamFN);

    printf("Reading NrPixelsY/Z from: %s\n", ParamFN);
    char aline[4096], key[1024], val_str[3072];
    while (fgets(aline, sizeof(aline), paramFile)) {
        if (aline[0] == '#' || isspace(aline[0]) || strlen(aline) < 3) continue;
        if (sscanf(aline, "%1023s %[^\n]", key, val_str) == 2) {
            if (strcmp(key, "NrPixelsY") == 0) sscanf(val_str, "%d", &NrPixelsY);
            else if (strcmp(key, "NrPixelsZ") == 0) sscanf(val_str, "%d", &NrPixelsZ);
            else if (strcmp(key, "NrPixels") == 0) { sscanf(val_str, "%d", &NrPixelsY); NrPixelsZ = NrPixelsY; }
        }
        // Stop if both are found
        if (NrPixelsY > 0 && NrPixelsZ > 0) break;
    }
    fclose(paramFile);
    check(NrPixelsY <= 0 || NrPixelsZ <= 0, "Failed to read valid NrPixelsY/Z from parameter file '%s'", ParamFN);
    printf(" - Found NrPixelsY = %d, NrPixelsZ = %d\n", NrPixelsY, NrPixelsZ);
    size_t total_detector_pixels = (size_t)NrPixelsY * NrPixelsZ;


    // --- Input File Paths ---
    const char *map_fn = "Map.bin";
    const char *nmap_fn = "nMap.bin";

    // --- Get Input File Sizes ---
    long map_size_bytes = get_file_size(map_fn);
    long nmap_size_bytes = get_file_size(nmap_fn);
    check(map_size_bytes < 0, "Cannot stat input file '%s'", map_fn);
    check(nmap_size_bytes < 0, "Cannot stat input file '%s'", nmap_fn);
    check(map_size_bytes == 0, "Input file '%s' is empty.", map_fn);
    check(nmap_size_bytes == 0, "Input file '%s' is empty.", nmap_fn);
    check(nmap_size_bytes % (2 * sizeof(int)) != 0, "Size of '%s' (%ld bytes) is not a multiple of 2*sizeof(int).", nmap_fn, nmap_size_bytes);
    check(map_size_bytes % sizeof(struct data) != 0, "Size of '%s' (%ld bytes) is not a multiple of sizeof(struct data).", map_fn, map_size_bytes);

    // Calculate number of integration bins (rows) and non-zeros
    int num_rows = nmap_size_bytes / (2 * sizeof(int));
    long long num_nonzeros = map_size_bytes / sizeof(struct data); // Total entries in Map.bin

    printf("Input Sizes:\n");
    printf(" - %s: %ld bytes (%lld entries)\n", map_fn, map_size_bytes, num_nonzeros);
    printf(" - %s: %ld bytes (%d bins)\n", nmap_fn, nmap_size_bytes, num_rows);

    // --- Allocate Memory for Input Data ---
    struct data *h_MapData = NULL;
    int *h_nMapData = NULL;
    printf("Allocating memory for input files...\n");
    h_MapData = malloc(map_size_bytes);
    check(h_MapData == NULL, "Failed to allocate memory for '%s' (%ld bytes)", map_fn, map_size_bytes);
    h_nMapData = malloc(nmap_size_bytes);
    check(h_nMapData == NULL, "Failed to allocate memory for '%s' (%ld bytes)", nmap_fn, nmap_size_bytes);


    // --- Read Input Files ---
    printf("Reading input files...\n");
    FILE *f_map = fopen(map_fn, "rb");
    check(f_map == NULL, "Failed to open input file '%s'", map_fn);
    size_t read_map = fread(h_MapData, 1, map_size_bytes, f_map);
    check(read_map != (size_t)map_size_bytes, "Failed to read full '%s' (read %zu/%ld bytes)", map_fn, read_map, map_size_bytes);
    fclose(f_map);
    printf(" - Read %s\n", map_fn);

    FILE *f_nmap = fopen(nmap_fn, "rb");
    check(f_nmap == NULL, "Failed to open input file '%s'", nmap_fn);
    size_t read_nmap = fread(h_nMapData, 1, nmap_size_bytes, f_nmap);
    check(read_nmap != (size_t)nmap_size_bytes, "Failed to read full '%s' (read %zu/%ld bytes)", nmap_fn, read_nmap, nmap_size_bytes);
    fclose(f_nmap);
    printf(" - Read %s\n", nmap_fn);

    // --- Allocate CSR Arrays ---
    printf("Allocating memory for CSR arrays (NNZ=%lld)...\n", num_nonzeros);
    double *csr_values = malloc(num_nonzeros * sizeof(double));
    int *csr_col_indices = malloc(num_nonzeros * sizeof(int));
    int *csr_row_ptr = malloc((num_rows + 1) * sizeof(int));
    check(!csr_values || !csr_col_indices || !csr_row_ptr, "Failed to allocate memory for CSR arrays");

    // --- Convert to CSR Format ---
    printf("Converting to CSR format...\n");
    long long current_nnz_idx = 0;
    long long total_count_check = 0;
    csr_row_ptr[0] = 0;

    for (int i = 0; i < num_rows; ++i) { // Iterate through integration bins (rows)
        int count = h_nMapData[i * 2];     // Number of pixels contributing to this bin
        int offset = h_nMapData[i * 2 + 1]; // Starting offset in h_MapData

        total_count_check += count; // Verify total count matches num_nonzeros later

        // Check offset validity
        check(offset < 0 || (offset + count) * sizeof(struct data) > (size_t)map_size_bytes,
              "Invalid offset/count for bin %d (offset=%d, count=%d) in '%s'", i, offset, count, nmap_fn);

        // Process entries for this bin
        for (int k = 0; k < count; ++k) {
            struct data current_entry = h_MapData[offset + k];

            // Calculate linear pixel index (column index)
            int pixel_col_idx = current_entry.z * NrPixelsY + current_entry.y;

            // Bounds check the calculated index
            check(pixel_col_idx < 0 || (size_t)pixel_col_idx >= total_detector_pixels,
                  "Calculated invalid pixel index %d for bin %d, entry %d (y=%d, z=%d). Check NrPixelsY/Z.",
                  pixel_col_idx, i, k, current_entry.y, current_entry.z);

            // Check current non-zero index bounds
             check(current_nnz_idx >= num_nonzeros,
                  "CSR index overflow! current_nnz_idx=%lld >= num_nonzeros=%lld at bin %d",
                  current_nnz_idx, num_nonzeros, i);

            // Store data in CSR arrays
            csr_values[current_nnz_idx] = current_entry.frac;
            csr_col_indices[current_nnz_idx] = pixel_col_idx;

            current_nnz_idx++;
        } // End loop over entries for this bin

        // Store the starting index for the *next* row
        csr_row_ptr[i + 1] = (int)current_nnz_idx;
        // Check for potential overflow if num_nonzeros > INT_MAX
        check(current_nnz_idx > INT_MAX, "CSR row pointer value exceeds INT_MAX at bin %d", i);

    } // End loop over bins (rows)

    printf("Conversion loop finished.\n");

    // --- Sanity Checks ---
    check(current_nnz_idx != num_nonzeros,
          "Final non-zero count mismatch! Expected %lld, counted %lld.", num_nonzeros, current_nnz_idx);
    check(total_count_check != num_nonzeros,
          "Sum of counts from nMap (%lld) does not match entries in Map (%lld).", total_count_check, num_nonzeros);
    printf("Sanity checks passed.\n");


    // --- Write CSR Files ---
    printf("Writing CSR output files...\n");
    const char *hdr_fn = "MapCSR.hdr";
    const char *val_fn = "MapCSR_values.bin";
    const char *col_fn = "MapCSR_col_indices.bin";
    const char *row_fn = "MapCSR_row_ptr.bin";

    // Write Header
    FILE *hdr_file = fopen(hdr_fn, "w");
    check(hdr_file == NULL, "Failed to open header file '%s'", hdr_fn);
    fprintf(hdr_file, "%d\n", num_rows);                // num_rows (integration bins)
    fprintf(hdr_file, "%zu\n", total_detector_pixels); // num_cols (detector pixels)
    fprintf(hdr_file, "%lld\n", num_nonzeros);          // num_nonzeros
    fclose(hdr_file);
    printf(" - Wrote %s\n", hdr_fn);

    // Write Values
    FILE *val_file = fopen(val_fn, "wb");
    check(val_file == NULL, "Failed to open values file '%s'", val_fn);
    size_t written_val = fwrite(csr_values, sizeof(double), num_nonzeros, val_file);
    check(written_val != num_nonzeros, "Failed to write full values data (%zu/%lld)", written_val, num_nonzeros);
    fclose(val_file);
    printf(" - Wrote %s (%zu bytes)\n", val_fn, written_val * sizeof(double));

    // Write Column Indices
    FILE *col_file = fopen(col_fn, "wb");
    check(col_file == NULL, "Failed to open col_indices file '%s'", col_fn);
    size_t written_col = fwrite(csr_col_indices, sizeof(int), num_nonzeros, col_file);
     check(written_col != num_nonzeros, "Failed to write full col_indices data (%zu/%lld)", written_col, num_nonzeros);
    fclose(col_file);
    printf(" - Wrote %s (%zu bytes)\n", col_fn, written_col * sizeof(int));

    // Write Row Pointer
    FILE *row_file = fopen(row_fn, "wb");
    check(row_file == NULL, "Failed to open row_ptr file '%s'", row_fn);
    size_t written_row = fwrite(csr_row_ptr, sizeof(int), num_rows + 1, row_file);
    check(written_row != (num_rows + 1), "Failed to write full row_ptr data (%zu/%d)", written_row, num_rows + 1);
    fclose(row_file);
    printf(" - Wrote %s (%zu bytes)\n", row_fn, written_row * sizeof(int));


    // --- Cleanup ---
    printf("Cleaning up memory...\n");
    free(h_MapData);
    free(h_nMapData);
    free(csr_values);
    free(csr_col_indices);
    free(csr_row_ptr);

    printf("MapConverter finished successfully.\n");
    return 0;
}